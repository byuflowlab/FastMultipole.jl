var documenterSearchIndex = {"docs":
[{"location":"advanced_usage/#Multiple-Systems","page":"Multiple Systems","title":"Multiple Systems","text":"The most advanced features of FastMultipole include:\n\nthe ability to solve the n-body problem for multiple systems simultaneously in a single FMM call\nsatisfy an error tolerance by dynamically adjusting the expansion order of multipole-to-local transformations\npredict the full array of FMM tuning parameters such that an error tolerance is met\n\nIn the this section, and continuing in Automated Tuning, we will first describe how to run the FMM for multi-system problems. Then, we will describe how to impose an error tolerance. Finally, we will show how to automatically tune the FMM parameters.","category":"section"},{"location":"advanced_usage/#Simultaneous-Computation-of-Several-Target-and-Source-Systems","page":"Multiple Systems","title":"Simultaneous Computation of Several Target and Source Systems","text":"FastMutipole allows FMM to be performed efficiently on distinct target and source systems. This is done by creating two octrees: one for sources, and one for targets [3]. For example, say we desire to know the influence of one system of point masses on another, but not vice versa. This is done by passing both systems to the fmm! function with the target system first, as:\n\nusing FastMultipole\nusing Random # needed for `gravitational.jl`\n\ngravitational_path = normpath(joinpath(splitdir(pathof(FastMultipole))[1], \"..\", \"test\", \"gravitational.jl\"))\ninclude(gravitational_path)\n\ntarget_system = generate_gravitational(123, 1000)\nsource_system = generate_gravitational(321, 1000)\n\nfmm!(target_system, source_system)\nprintln(\"gravitational acceleration: \", target_system.potential[5:7,1:10], \"...\")\n\ntip: Tip\nThe fmm! function can take any number of target and source systems, so long as they are passed as tuples. This allows for the simultaneous evaluation of multiple source systems on multiple target systems.\n\nIn practice, the source system might be a collection of systems, composed of a variety of datastructures. So long as the interface functions are defined for each system, we can pass a tuple of any number of systems as the source and or target. For example, we could evaluate the influence of a system of point masses, point vortices, and vortex filaments on two different target systems:\n\nusing LinearAlgebra\n\n# include vortex filament and particle models and interface functions\nvortex_path = normpath(joinpath(splitdir(pathof(FastMultipole))[1], \"..\", \"test\", \"vortex.jl\"))\ninclude(vortex_path)\nfilament_path = normpath(joinpath(splitdir(pathof(FastMultipole))[1], \"..\", \"test\", \"vortex_filament.jl\"))\ninclude(filament_path)\n\n# generate systems\nn_bodies = 2000\ntarget_one = generate_gravitational(123, n_bodies)\ntarget_two = generate_vortex(124, n_bodies)\nsource_one = generate_gravitational(125, n_bodies)\nsource_two = generate_vortex(126, n_bodies)\nsource_three = generate_filament_field(n_bodies, n_bodies^0.333, 127; strength_scale=1/n_bodies)\n\n# run FMM\nfmm!((target_one, target_two), (source_one, source_two, source_three);\n    scalar_potential=false, gradient=true, hessian=(false, true))\n\nv1 = target_one.potential[5:7,:]\nv2 = target_two.gradient_stretching[1:3,:]\n\n# run direct\ntarget_one.potential .= 0.0\ntarget_two.potential .= 0.0\ntarget_two.gradient_stretching .= 0.0\ndirect!((target_one, target_two), (source_one, source_two, source_three); scalar_potential=false, gradient=true, hessian=(false, true))\n\n# test accuracy\nprintln(\"max error in target one: \", maximum(abs.(target_one.potential[5:7,:] .- v1)))\nprintln(\"max error in target two: \", maximum(abs.(target_two.gradient_stretching[1:3,:] .- v2)))\n\nNote that scalar_potential, gradient, and hessian can be passed as a single boolean or as a tuple of booleans, one for each target system. This allows the user to specify which values are desired for each target system, and avoids unnecessary calculations for values that are not needed. In this case, we have set scalar_potential=false and gradient=true to indicate all target systems, but a tuple hessian=(false,true) to indicate different settings for each. It is worth remembering that these switches must be implemented by the user when overloading the direct! function for each system to act as a source.\n\ntip: Tip\nThe fmm! keyword arguments scalar_potential, gradient, and hessian can be passed as a single boolean or as a tuple of booleans, one for each target system. This allows the user to specify which values are desired for each target system, and avoids unnecessary calculations for values that are not needed.","category":"section"},{"location":"guided_examples/#Gravitational-Example","page":"Gravitational Example","title":"Gravitational Example","text":"FastMultipole is designed to incorporate easily into your existing Julia code with minimal effort. In this section and the Vortex Filament Example, we demonstrate how this can be done.\n\nFirst, we'll review the interface functions used by the gravitational point mass model used in Quick Start. This code can also be found under FastMultipole/test/gravitational.jl.\n\nTo better understand how the FastMultipole interface functions, let's take a look at the data structures we'll use to define our point masses:\n\nusing FastMultipole\nusing FastMultipole.StaticArrays\n\nconst i_POTENTIAL = 1:1   # index of the gravitational potential\nconst i_GRADIENT = 5:7    # index of the gravitational acceleration\nconst i_HESSIAN = 8:16    # index of the hessian matrix\n\n# a single point mass\nstruct Body{TF}\n    position::SVector{3,TF}\n    radius::TF\n    strength::TF\nend\n\n# container for a system of `Body`'s\nstruct Gravitational{TF}\n    bodies::Vector{Body{TF}}\n    potential::Matrix{TF}\nend\n\n# constructor\nfunction Gravitational(bodies::Matrix)\n    nbodies = size(bodies)[2]\n    bodies2 = [Body(SVector{3}(bodies[1:3,i]),bodies[4,i],bodies[5,i]) for i in 1:nbodies]\n    potential = zeros(eltype(bodies), 16, nbodies)\n    return Gravitational(bodies2,potential)\nend\n\nIn short, Body objects represent individual point masses, and the Gravitational object contains a group of them, along with a matrix of the potential, velocity, and velocity gradient at each body. The observant reader will notice that the strength field of Body represents its mass. ","category":"section"},{"location":"guided_examples/#Overloading-body_to_multipole!","page":"Gravitational Example","title":"Overloading body_to_multipole!","text":"The function body_to_multipole! is used to generate multipole expansions for our particular system. This is done be overloading FastMultipole.body_to_multipole! for our data structure. Convenience functions exist within FastMultipole to simplify this complicated function into a one-liner:\n\nFastMultipole.body_to_multipole!(system::Gravitational, args...) =\n    FastMultipole.body_to_multipole!(Point{Source}, system, args...)\n\nThe ::Gravitational type annotation is the key that allows FastMultipole to dispatch on ::Gravitational systems. Point{Source} is used to indicate that our bodies are points and induce a source (i.e. 1r) potential. Other convenience functions exist in FastMultipole for any combination of Point, Filament, or Panel geometries using Source, Dipole, or Vortex kernels, and are specified when overloading body_to_multipole! as <geometry>{<kernel>}. For example, if my model used constant vortex sheet panels, I would replace Point{Source} in the example above to Panel{Vortex}.\n\ntip: Tip\nFastMultipole provides convenience functions for generating multipole coefficients for any combination of Point, Filament, or Panel geometries using Source, Dipole, or Vortex kernels. These are specified when overloading body_to_multipole! as <geometry>{<kernel>}.\n\nWe use the fast recursive method of generating exact coefficients for panels as developed by [1]. We have derived our own formulae for vortex filaments and panels, which are in the process of publication.\n\nFastMultipole also requires the user to indicate if a source system induces a vector potential. This is done by overloading the has_vector_potential function as follows:\n\nfunction FastMultipole.has_vector_potential(system::Gravitational)\n    return false\nend\n\nThis will allow FastMultipole to avoid unnecessary calculations if the vector potential is not needed. Since Gravitational systems do not induce a vector potential, we return false.","category":"section"},{"location":"guided_examples/#Buffer-Interface-Functions","page":"Gravitational Example","title":"Buffer Interface Functions","text":"FastMultipole allocates a buffer matrix in which to sort and store key system information. The buffer interface is created by overloading several functions for the user-defined system type. The first of these functions is FastMultipole.source_system_to_buffer!, which populates a matrix with the important information about each body, column-wise. Overloading for ::Gravitational systems looks like this:\n\nfunction FastMultipole.source_system_to_buffer!(buffer, i_buffer, system::Gravitational, i_body)\n    buffer[1:3, i_buffer] .= system.bodies[i_body].position\n    buffer[4, i_buffer] = system.bodies[i_body].radius\n    buffer[5, i_buffer] = system.bodies[i_body].strength\nend\n\nHere, the i_bodyth body position, radius, and strength are copied to the correct positions in the i_bufferth column of the buffer matrix.\n\nIt is worth noting that there are ways of defining these functions that would harm performance, e.g. by allocating an array each time the velocity is requested. If you notice FastMultipole's performance is poor, this and the other interface functions are good places to check.\n\nwarning: Warning\nThe user-defined buffer interface functions are used frequently during an FMM call, so it is important to write them efficiently, avoiding allocations and following the Julia performance tips. If you notice that FastMultipole's performance is poor, this might be the reason.\n\nBecause every system can have a unique buffer structure, we need to overload a few additional functions to tell FastMultipole how to allocate and access it. The first function, data_per_body, returns the number of rows in the buffer matrix that are used to define a single body. The second function, get_position, returns the position of the ith body in the system. The third function, strength_dims, returns the number of rows in the buffer matrix that are used to define the strength of a single body. Finally, we overload get_n_bodies to return the number of bodies in our system. Note that in case Base.eltype is already overloaded and doesn't return a <:Number type, users may optionally overload FastMultipole.numtype instead. For our Gravitational system, we define:\n\nBase.eltype(::Gravitational{TF}) where TF = TF\n\nfunction FastMultipole.data_per_body(system::Gravitational)\n    return 5\nend\n\nfunction FastMultipole.get_position(system::Gravitational, i)\n    return system.bodies[i].position\nend\n\nfunction FastMultipole.strength_dims(system::Gravitational)\n    return 1\nend\n\nFastMultipole.get_n_bodies(system::Gravitational) = length(system.bodies)\n\nThese functions provide enough information for FastMultipole to allocate the buffer matrix and access the data it needs.\n\nFinally, we need to tell FastMultipole how to transfer the results of the FMM call back to the user-defined system. This is done by overloading the FastMultipole.buffer_to_target_system! function. Overloading for ::Gravitational systems looks like this:\n\nfunction FastMultipole.buffer_to_target_system!(target_system::Gravitational, i_target, ::FastMultipole.DerivativesSwitch{PS,VS,GS}, target_buffer, i_buffer) where {PS,VS,GS}\n    # get values\n    TF = eltype(target_buffer)\n    scalar_potential = PS ? FastMultipole.get_scalar_potential(target_buffer, i_buffer) : zero(TF)\n    velocity = VS ? FastMultipole.get_gradient(target_buffer, i_buffer) : zero(SVector{3,TF})\n    hessian = GS ? FastMultipole.get_hessian(target_buffer, i_buffer) : zero(SMatrix{3,3,TF,9})\n\n    # update system\n    target_system.potential[i_POTENTIAL[1], i_target] = scalar_potential\n    target_system.potential[i_GRADIENT, i_target] .= velocity\n    for (jj,j) in enumerate(i_HESSIAN)\n        target_system.potential[j, i_target] = hessian[jj]\n    end\nend\n\nWe note that the convenience functions get_gradient and get_hessian return ::SVector{3} and ::SMatrix{3,3}, respectively, to reduce allocations.","category":"section"},{"location":"guided_examples/#Overloading-direct!","page":"Gravitational Example","title":"Overloading direct!","text":"The last required interface function is FastMultipole.direct!, which evaluates the potential at a target system using a source system without multipole acceleration. This is required in an FMM call for those interactions that are too close to be approximated by expansions. It is also useful for debugging and testing the accuracy of the FMM call. Overloading for ::Gravitational systems, we have:\n\nfunction FastMultipole.direct!(target_system, target_index, ::DerivativesSwitch{PS,VS,GS}, source_system::Gravitational, source_buffer, source_index) where {PS,VS,GS}\n    @inbounds for i_source in source_index\n        source_x, source_y, source_z = FastMultipole.get_position(source_buffer, i_source)\n        source_strength = FastMultipole.get_strength(source_buffer, source_system, i_source)[1]\n        @inbounds for j_target in target_index\n            target_x, target_y, target_z = FastMultipole.get_position(target_system, j_target)\n            dx = target_x - source_x\n            dy = target_y - source_y\n            dz = target_z - source_z\n            r2 = dx*dx + dy*dy + dz*dz\n            if r2 > 0\n                r = sqrt(r2)\n                if PS\n                    dϕ = source_strength / r * FastMultipole.ONE_OVER_4π\n                    FastMultipole.set_scalar_potential!(target_system, j_target, dϕ)\n                end\n                if VS\n                    dF = SVector{3}(dx,dy,dz) * source_strength / (r2 * r) * FastMultipole.ONE_OVER_4π\n                    FastMultipole.set_gradient!(target_system, j_target, dF)\n                end\n            end\n        end\n    end\nend\n\nNote that the velocity gradient is not calculated in this function. If the velocity gradient is requested, the contribution due to ::Gravitational systems will then be zero.\n\ntip: Tip\nUse the boolean type parameters of the ::DerivativesSwitch{PS,GS,HS} argument when overloading the direct! to know when to compute the scalar potential, its gradient, and its hessian, respectively. This can save cost by avoiding unnecessary calculations.","category":"section"},{"location":"guided_examples/#Running-the-FMM","page":"Gravitational Example","title":"Running the FMM","text":"Now that we have defined the interface functions, we can run the FMM on our Gravitational system to obtain the gravitational acceleration at each body. The fmm! function is used to perform the FMM call as:\n\nusing Random\n\n# create system\nfunction generate_gravitational(seed, n_bodies; radius_factor=0.1, strength_scale=1/n_bodies, bodies_fun=(x)->x)\n    # random seed\n    Random.seed!(seed)\n\n    # initialize bodies\n    bodies = rand(5, n_bodies)\n\n    # scale radius\n    bodies[4,:] ./= (n_bodies^(1/3)*2)\n    bodies[4,:] .*= radius_factor\n\n    # scale strength\n    bodies[5,:] .*= strength_scale\n\n    # user-defined function for arbitrary transformation\n    bodies_fun(bodies)\n\n    # create system\n    return Gravitational(bodies)\nend\n\nn_bodies, rand_seed = 5_000, 123\nsystem = generate_gravitational(rand_seed, n_bodies)\n\n# run FMM\nfmm!(system; scalar_potential=false, gradient=true, hessian=true)\n\nprintln(\"gravitational acceleration:\\n\", system.potential[5:7,1:10], \"...\")\n\nThe scalar_potential and gradient arguments are set to false and true, respectively, to indicate that we want to compute the vector field (i.e. the gravitational field lines that translate to force and their gradient) but not the scalar potential.\n\nwarning: Warning\nThe user must specify which fields they want to be computed by the FMM by setting the boolean keyword arguments scalar_potential, gradient, and hessian when calling fmm! (defaults are scalar_potential=false, gradient=true, and hessian=false). Note also that if the source system induces a vector potential (as indicated by the interface function has_vector_potential(system)=true), then the scalar_potential keyword should be set to false, since the scalar potential will be non-sensical in this case.","category":"section"},{"location":"guided_examples/#Preallocating-the-Buffers","page":"Gravitational Example","title":"Preallocating the Buffers","text":"The fmm! function incurs a small overhead for allocating the buffer matrices. If our system is large and the FMM will be called more than once, we can preallocate the buffers to avoid this overhead. This is done by returning a cache of preallocated memory the first time fmm! is called, and then adding it as an additional argument to fmm! in subsequent calls as follows:\n\n# allocate buffer cache\nallocs_1 = @allocated _, cache, _ = fmm!(system; scalar_potential=false, gradient=true, hessian=true)\n\n# run FMM with preallocated buffers\nallocs_2 = @allocated fmm!(system, cache; scalar_potential=false, gradient=true, hessian=true)\n\nprintln(\"memory allocated without the cache:  \", allocs_1, \" bytes\")\nprintln(\"memory allocated with the cache:     \", allocs_2, \" bytes\")\n\nNote that the second call to fmm! allocates less memory.\n\ntip: Tip\nIf you plan to call fmm! multiple times on the same system, consider preallocating the buffers by saving the cache returned by the first call, and splatting it as a keyword argument for each subsequent call. This can reduce memory allocations and improve performance.","category":"section"},{"location":"advanced_usage_2/#Automated-Tuning","page":"Automated Tuning","title":"Automated Tuning","text":"In the this section, we will describe how to impose an error tolerance. Finally, we will show how to automatically tune the FMM parameters.","category":"section"},{"location":"advanced_usage_2/#Satisfying-an-Error-Tolerance","page":"Automated Tuning","title":"Satisfying an Error Tolerance","text":"FastMultipole can be configured to satisfy an error tolerance by dynamically adjusting the expansion order of each multipole-to-local transformation to the smallest integer that satisfies the tolerance, according to an error prediction. Users can indicate their desired error tolerance via the keyword argument error_tolerance in the fmm! function. A value of nothing indicates no error tolerance, in which case the expansion order is fixed at whatever is passed as the expansion_order keyword. Otherwise, error_tolerance should inherit from the ErrorMethod abstract type. The chosen type will determine how the error is predicted, and hence how the expansion order is chosen. Choices include:\n\nPowerAbsolutePotential{tolerance, BE::Bool}: Constrains the magnitude of the potential error to be less than tolerance using a radially invariant upper bound.\nPowerAbsoluteGradient{tolerance, BE::Bool}: Constrains the magnitude of the vector field error to be less than tolerance using a radially invariant upper bound.\nPowerRelativePotential{relative_tolerance, absolute_tolerance, BE::Bool}: Constrains the relative error of the potential to be less than relative_tolerance using a radially invariant upper bound. If the equivalent absolute tolerance of an interaction is less than absolute_tolerance, then absolute_tolerance is used instead.\nPowerRelativeGradient{relative_tolerance, absolute_tolerance, BE::Bool}: Constrains the relative error of the vector field to be less than relative_tolerance using a radially invariant upper bound. If the equivalent absolute tolerance of an interaction is less than absolute_tolerance, then absolute_tolerance is used instead.\n\nSince each error \n\ninfo: Info\nFor relative error methods, the get_previous_influence compatibility function must be overloaded for your target system. This function estimates the potential and gradient at the ith target body, which is used to compute the relative error. For example, estimates might be based on the previous step of a time-stepping or iterative algorithm.\n\nSay I wanted to compute the gravitational potential to a tolerance of 1e-6 using the absolute potential error method. I would call the FMM as follows:\n\n\nusing FastMultipole\nusing Random # needed for `gravitational.jl`\n\ngravitational_path = normpath(joinpath(splitdir(pathof(FastMultipole))[1], \"..\", \"test\", \"gravitational.jl\"))\ninclude(gravitational_path)\n\n# create system\nn_bodies, rand_seed = 5_000, 123\nsystem = generate_gravitational(rand_seed, n_bodies)\n\n# run FMM with error tolerance\nfmm!(system; scalar_potential=true, gradient=false, hessian=false, error_tolerance=PowerAbsolutePotential(1e-6), expansion_order=8)\n\n# print potential\nprintln(\"gravitational potential:\\n\", system.potential[1,1:10], \"...\")\n\nThis keyword argument error_tolerance=PowerAbsolutePotential(1e-6) requests that the expansion order be dynamically adjusted to ensure that the potential error of each interaction is less than 1e-6 at each body. Note that this does ensure a perfectly conservative error bound, since many multipole-to-local transformations will be performed to any given target cell. However, the maximum error should be within an order of magnitude of the specified tolerance, and the average error will be much lower. It is also worth pointing out that the expansion_order keyword determines the maximum allowable expansion order; if it is too small, then FastMultipole will not be able to satisfy the error tolerance, and will show a warning. In this case, the expansion order is set to 8, which is sufficient to satisfy the error tolerance.\n\n# verify error\nphi_fmm = system.potential[1,:]\nsystem.potential .= 0.0\ndirect!(system; scalar_potential=true, gradient=false, hessian=false)\nphi_direct = system.potential[1,:]\nprintln(\"max potential error: \", maximum(abs.(phi_direct .- phi_fmm)))\n\nIt is also worth noting that the expansion order is never allowed to be less than 1, which leads to \"bottoming out\" behavior. Let's see what happens when we request a tolerance of 1e-2:\n\n# run FMM with error tolerance\nsystem.potential .= 0.0\nfmm!(system; scalar_potential=true, gradient=false, hessian=false, error_tolerance=PowerAbsolutePotential(1e-2))\n\n# check error\nphi_fmm = system.potential[1,:]\nprintln(\"max error:\\n\", maximum(abs.(phi_direct .- phi_fmm)))\n\nAs a rule of thumb, PowerAbsolutePotential and PowerAbsoluteGradient are best when the maximum error is to be constrained, while RotatedCoefficientsAbsoluteGradient is better if the mean error is to be constrained.\n\ninfo: Info\nWhen imposing an error tolerance, the PowerAbsolutePotential and PowerAbsoluteGradient methods are best when the maximum error is to be constrained, while RotatedCoefficientsAbsoluteGradient is better if the mean error is to be constrained.","category":"section"},{"location":"advanced_usage_2/#Fully-Automatic-Tuning-of-FMM-Parameters","page":"Automated Tuning","title":"Fully Automatic Tuning of FMM Parameters","text":"FastMultipole can automatically tune the FMM parameters to satisfy an error tolerance. This is done by running the tune_fmm function, which returns a named tuple of the optimal parameters and a preallocated buffer to reduce memory allocations.\n\nSay I wanted the optimal tuning parameters for the gravitational potential of a system of point masses, with a maximum error tolerance of 1e-4. I would call the function as follows:\n\nopt_params, cache = tune_fmm(system; error_tolerance=PowerAbsolutePotential(1e-4), scalar_potential=true, gradient=false, hessian=false)\nprintln(\"Optimal parameters: \", opt_params)\n\nThis will return a named tuple of the optimal parameters, which can then be passed to the fmm! function. The cache is a preallocated buffer that can be used to reduce memory allocations during the FMM call.\n\n# run FMM without default parameters\nprintln(\"Default Tuning Parameters:\")\nsystem.potential .= 0.0\nt1 = @elapsed fmm!(system; scalar_potential=true, gradient=false, hessian=false, error_tolerance=PowerAbsolutePotential(1e-4))\n\n# verify error\nphi_fmm = system.potential[1,:]\nprintln(\"\\tmax error: \", maximum(abs.(phi_direct .- phi_fmm)))\nprintln(\"\\ttime cost: \", t1, \" seconds\")\n\n# run FMM with optimal parameters\nprintln(\"Optimal Tuning Parameters:\")\nt2 = @elapsed fmm!(system, cache; scalar_potential=true, gradient=false, hessian=false, error_tolerance=PowerAbsolutePotential(1e-4), opt_params...)\n\n# verify error\nprintln(\"\\tmax error: \", maximum(abs.(phi_direct .- phi_fmm)))\nprintln(\"\\ttime cost: \", t2, \" seconds\")\n\nNote that the tune_fmm function iterates over each requested multipole_acceptance criterion, so it is not optimal to call it before every FMM call. Instead, tune_fmm can be called once for a representative system primarily to choose multipole_acceptance. Since the optimal parameters depend on the size, distribution, and strengths of the sources and targets, it is recommended to set the keyword argument tune=true to iteratively update the expansion_order and leaf_size_source parameters each time fmm! is called. This will allow the FMM to adapt to the system as it evolves, and will ensure that the optimal parameters are used for each call.\n\ntip: Tip\nThe tune_fmm function can be used to automatically tune the FMM parameters to satisfy an error tolerance. It returns a named tuple of the optimal parameters and a preallocated buffer to reduce memory allocations.\n\nwarning: Warning\nThe tune_fmm function is computationally expensive, so it should not be called before every FMM call. Instead, it should be called once for a representative system to choose the optimal multipole_acceptance parameter. Then, the optimal parameters will be updated in each fmm! call if the tune=true keyword argument is set. This allows the FMM to adapt to the system as it evolves.","category":"section"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"In a nutshell, FastMultipole operates by forming series expansions of a kernel function, and translating and combining those expansions to obtain optimal compression. You can get a sense for how this works in the following figure.\n\n<img src=\"../assets/multipole_expansions.png\" width=\"660px\"/>\n\nHere, we see how each body's influence can be expressed as a series expansion. These series expansions can be translated and combined such that an entire cluster of bodies is represented by a single series expansion. This is what is known as a multipole expansion. Multipole expansions only converge outside of a finite radius of convergence, as illustrated by the red dotted line. Multipole expansions can only be used for interactions that are farther apart than this circl. The accuracy of the expansion gets better and better the farther away we go, so we can control the accuracy by imposing a cutoff radius (dotted blue line), and only use multipole expansions for interactions that are farther away than the blue circle. Multipole expansions are very helpful for reducing the cost of the N-body problem; in fact, we can reduce the scaling of the N-body problem to O(NlogN) by only considering multipole expansions.\n\nLocal expansions are very similar to multipole expansions, but they converge inside of a finite radius rather than outside. These provide the additional required compression to achieve fully O(N) scaling. In the next figure, we see how local expansions can reduce the number of times an expansion need be evaluated.\n\n<img src=\"../assets/local_expansions.png\" width=\"660px\"/>\n\nMore details of the fast multipole method (FMM) can be found in the original work by Greengard and Rokhlin.[4]","category":"section"},{"location":"theory/#References","page":"Theory","title":"References","text":"N. A. Gumerov, S. Kaneko and R. Duraiswami. Recursive computation of the multipole expansions of layer potential integrals over simplices for efficient fast multipole accelerated boundary elements. Journal of Computational Physics 486, 112118 (2023).\n\n\n\nN. A. Gumerov and R. Duraiswami. Efficient FMM accelerated vortex methods in three dimensions via the Lamb–Helmholtz decomposition. Journal of Computational Physics 240, 310–328 (2013).\n\n\n\nR. Yokota. An FMM based on dual tree traversal for many-core architectures. Journal of Algorithms & Computational Technology 7, 301–324 (2013).\n\n\n\nL. Greengard and V. Rokhlin. A fast algorithm for particle simulations. Journal of computational physics 73, 325–348 (1987).\n\n\n\n","category":"section"},{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"The following tutorial shows how to use FastMultipole to compute the gravitational potential induced by a collection of point masses. It uses data structures located in test/gravitational.jl.","category":"section"},{"location":"quickstart/#Create-a-System","page":"Quick Start","title":"Create a System","text":"First, let's create a system of 1000 randomly spaced point masses:\n\nusing FastMultipole\nusing Random # needed for `gravitational.jl`\n\ngravitational_path = normpath(joinpath(splitdir(pathof(FastMultipole))[1], \"..\", \"test\", \"gravitational.jl\"))\ninclude(gravitational_path)\n\nrand_seed = 123\nn_bodies = 4000\nsystem = generate_gravitational(rand_seed, n_bodies)\nprintln(\"System of type $(typeof(system)) created with \", n_bodies, \" bodies.\")","category":"section"},{"location":"quickstart/#Evaluate-The-Potential-at-Each-Body","page":"Quick Start","title":"Evaluate The Potential at Each Body","text":"The fmm! function evaluates the gravitational potential induced by system in-place. We can control the tradeoff between performance and accuracy with a handful of tuning parameters, but we'll stick with the defaults for this example:\n\nfmm!(system; scalar_potential=true)\n\nThe resulting potential can then be accessed in the user-defined system object.\n\n@show system.potential[1,1:10] # show first 10 potentials\n\nLet me emphasize that system can be any user-defined object, so long as a few interface functions are defined (we'll go over those later). This allows you to use FastMultipole in your existing code with almost no modifications.","category":"section"},{"location":"quickstart/#Accuracy-of-FMM-Call","page":"Quick Start","title":"Accuracy of FMM Call","text":"By using the direct! function, we can check the accuracy of the fmm! call by evaluating the ''N''-body problem naively, without fast multipole acceleration.\n\n# store fmm potential\nfmm_potential = system.potential[1,:]\n\n# reset the system\nsystem.potential .= 0.0\n\n# evaluate the potential directly\ndirect!(system; scalar_potential=true)\ndirect_potential = system.potential[1,:]\n\n# compute the percent error\npercent_error = abs.((fmm_potential[1,:] .- direct_potential[1,:]) ./ direct_potential[1,:]) .* 100\n\nprintln(\"max percent error: \", maximum(percent_error), \"%\")","category":"section"},{"location":"quickstart/#Scalar-plus-Vector-Potential-Applications","page":"Quick Start","title":"Scalar-plus-Vector Potential Applications","text":"The use of a scalar-plus-vector potential is quite general, and is useful in a variety of physics and engineering contexts, including fluid dynamics, linear elasticity, electromagnetism, astrophysics, and others. We include a table of some common field quantities that derive from the scalar-plus-vector potential, along with their corresponding fmm! keyword arguments and physical interpretations.\n\nvecv = nabla phi + nabla times vecpsi\n\n phi vecpsi vecv nabla vecv\nfmm! Keyword Arguments scalar_potential vector_potential gradient hessian\nFluid Dynamics Scalar Potential Stream Function Fluid Velocity Velocity Gradient\nElectrostatics Electric Potential - Electric Field Field Gradient Tensor\nMagnetostatics - Magnetic Vector Potential Magnetic Field Field Gradient Tensor\nAstrophysics Gravitational Potential - Gravitational Acceleration Acceleration Gradient Tensor","category":"section"},{"location":"tuning/#Tuning-Parameters","page":"Tuning Parameters","title":"Tuning Parameters","text":"The FMM can be tuned for accuracy and performance by adjusting the following parameters: multipole_acceptance, leaf_size, and expansion_order. These parameters are passed to the fmm! function as keyword arguments. Let's take a look at how each affects the FMM. ","category":"section"},{"location":"tuning/#Expansion-Order","page":"Tuning Parameters","title":"Expansion Order","text":"First we'll try varying the expansion_order, or the degree of the expansions used:\n\nusing FastMultipole # hide\nusing Random # hide\ngravitational_path = normpath(joinpath(splitdir(pathof(FastMultipole))[1], \"..\", \"test\", \"gravitational.jl\")) # hide\ninclude(gravitational_path) # hide\n# create system\nn_bodies, rand_seed = 10000, 123\nsystem = generate_gravitational(rand_seed, n_bodies)\n\n# compute potential directly\ndirect!(system; gradient=true)\ngradient_direct = system.potential[5:7,:]\n\n# try varying `expansion_order`\nprintln(\"#--- varying expansion order ---#\\n\")\nprintln(\"expansion_order = 1\")\nfmm!(system; expansion_order=1, multipole_acceptance=0.5, leaf_size=30, gradient=true)\nsystem.potential .= 0.0\nt_e_1 = @elapsed fmm!(system; expansion_order=3, multipole_acceptance=0.5, leaf_size=30, gradient=true)\nprintln(\"\\ttime cost: \", t_e_1, \" seconds\")\nprintln(\"\\tmax error: \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\n\nprintln(\"expansion_order = 4\")\nsystem.potential .= 0.0\nt_e_4 = @elapsed fmm!(system; expansion_order=4, multipole_acceptance=0.5, leaf_size=30, gradient=true)\nprintln(\"\\ttime cost: \", t_e_4, \" seconds\")\nprintln(\"\\tmax error: \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\n\nprintln(\"expansion_order = 8\")\nsystem.potential .= 0.0\nt_e_8 = @elapsed fmm!(system; expansion_order=8, multipole_acceptance=0.5, leaf_size=30, gradient=true)\nprintln(\"\\ttime cost: \", t_e_8, \" seconds\")\nprintln(\"\\tmax error: \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\n\nThe expansion_order parameter is always positively correlated to accuracy but negatively correlated to cost. ","category":"section"},{"location":"tuning/#Multipole-Acceptance-Criterion-(MAC)","page":"Tuning Parameters","title":"Multipole Acceptance Criterion (MAC)","text":"Now, let's explore the multipole_acceptance criterion. It must be between 0.0 and 1.0, and indicates the smallest acceptable distance beyond which multipole expansions are allowed.\n\n# try varying `multipole_acceptance`\nprintln(\"#--- varying multipole acceptance ---#\\n\")\n\nprintln(\"multipole_acceptance = 0.3\")\nsystem.potential .= 0.0\nt_m_3 = @elapsed fmm!(system; expansion_order=4, multipole_acceptance=0.3, leaf_size=30, scalar_potential=true, gradient=true)\nprintln(\"\\ttime cost: \", t_m_3, \" seconds\")\nprintln(\"\\tmax error: \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\n\nprintln(\"multipole_acceptance = 0.5\")\nsystem.potential .= 0.0\nt_m_5 = @elapsed fmm!(system; expansion_order=4, multipole_acceptance=0.5, leaf_size=30, scalar_potential=true, gradient=true)\nprintln(\"\\ttime cost: \", t_m_5, \" seconds\")\nprintln(\"\\tmax error: \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\n\nprintln(\"multipole_acceptance = 0.7\")\nsystem.potential .= 0.0\nt_m_7 = @elapsed fmm!(system; expansion_order=4, multipole_acceptance=0.7, leaf_size=30, scalar_potential=true, gradient=true)\nprintln(\"\\ttime cost: \", t_m_7, \" seconds\")\nprintln(\"\\tmax error: \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\n\nThe multipole_acceptance parameter is negatively correlated to accuracy. In this case, it is also negatively correlated to cost, but that won't always be true, depending on the cost of the direct! function.","category":"section"},{"location":"tuning/#Leaf-Size","page":"Tuning Parameters","title":"Leaf Size","text":"Finally, let's explore the leaf_size parameter, which controls the size of the leaf nodes in the octree:\n\n# try varying `leaf_size`\nprintln(\"#--- varying leaf size ---#\\n\")\n\nprintln(\"leaf_size = 5\")\nsystem.potential .= 0.0\nt_l_5 = @elapsed fmm!(system; expansion_order=4, multipole_acceptance=0.5, leaf_size=5, gradient=true)\nprintln(\"\\ttime cost: \", t_l_5, \" seconds\")\nprintln(\"\\tmax error: \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\n\nprintln(\"leaf_size = 20\")\nsystem.potential .= 0.0\nt_l_20 = @elapsed fmm!(system; expansion_order=4, multipole_acceptance=0.5, leaf_size=20, gradient=true)\nprintln(\"\\ttime cost: \", t_l_20, \" seconds\")\nprintln(\"\\tmax error: \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\n\nprintln(\"leaf_size = 100\")\nsystem.potential .= 0.0\nt_l_80 = @elapsed fmm!(system; expansion_order=4, multipole_acceptance=0.5, leaf_size=80, gradient=true)\nprintln(\"\\ttime cost: \", t_l_80, \" seconds\")\nprintln(\"\\tmax error: \", maximum(abs.(system.potential[5:7,:] .- gradient_direct)))\n\nThe leaf_size parameter is positively correlated to accuracy, but its relation to cost is less predictable. \n\nThe complicated relationship between these parameters, the cost, and the accuracy of the FMM motivates automated tuning of the parameters, which we'll explore in Automated Tuning.\n\ntip: Tip\nTuning parameters can have an order-of-magnitude impact on the performance of FMM. The expansion_order parameter is positively correlated to accuracy but negatively correlated to cost. The multipole_acceptance and leaf_size parameters are still correlated, but less predictably so. This motivates automated tuning of the parameters, which we'll explore in the next example.","category":"section"},{"location":"tuning/#Optimal-Leaf-Size","page":"Tuning Parameters","title":"Optimal Leaf Size","text":"We can request FastMultipole to predict the optimal leaf size for our system by setting tune=true in the fmm! call. This performs best when interaction_list_method=SelfTuning() on a single thread, but still functions well for other choices. If tune=true, benchmarks will be used to estimate the leaf size at which the cost of direct calculations is approximately equal to expansion calculations. It is returned as part of a named tuple as the first returned value of fmm!, which can be splatted as a keyword argument in subsequent fmm! calls:\n\n# get optimal leaf size\nprintln(\"#--- default leaf size ---#\\n\")\nt1 = @elapsed optargs, _ = fmm!(system; tune=true, gradient=true)\nprintln(\"\\ttime cost: \", t1, \" seconds\")\n\n# run again with optimal leaf size\nprintln(\"\\n#--- optimal leaf size ---#\\n\")\nt2 = @elapsed fmm!(system; scalar_potential=false, gradient=true, optargs...)\nprintln(\"\\ttime cost: \", t2, \" seconds\")\n\nNote that optargs contains leaf_size_source, expansion_order, and multipole_acceptance parameters. Only leaf_size_source is tuned if isnothing(error_tolerance) == true. More complete auto-tuning will be discussed in Advanced Usage.","category":"section"},{"location":"vortex_filament/#Vortex-Filament-Example","page":"Vortex Filament Example","title":"Vortex Filament Example","text":"In this example, we review the interface functions used by the vortex filament model found in FastMultipole/test/vortex_filament.jl. First, let's take a look at the data structure:\n\nusing FastMultipole # hide\nusing FastMultipole.StaticArrays # hide\nstruct VortexFilaments{TF}\n    x::Matrix{SVector{3,TF}}\n    strength::Vector{SVector{3,TF}}\n    core_size::Vector{TF}\n    error_tolerance::Vector{TF}\n    potential::Vector{TF}\n    gradient::Vector{SVector{3,TF}}\n    hessian::Vector{SMatrix{3,3,TF,9}}\nend\n\nNote that x is a 2-row matrix, where the first row contains the start point of the filament and the second row contains the end point. The strength field contains the strength of the vortex filament, which is a vector quantity. The core_size field contains the regularization radius for each filament. The potential, force, and gradient fields are used to store the results of the FMM call.","category":"section"},{"location":"vortex_filament/#Overloading-body_to_multipole!","page":"Vortex Filament Example","title":"Overloading body_to_multipole!","text":"Just like we did for the gravitational example, we need to overload FastMultipole.body_to_multipole! and FastMultipole.has_vector_potential for our vortex filament system. The recommended way to do this is:\n\nFastMultipole.body_to_multipole!(system::VortexFilaments, args...) = \n    FastMultipole.body_to_multipole!(Filament{Vortex}, system, args...)\n\nfunction FastMultipole.has_vector_potential(system::VortexFilaments)\n    return true\nend\n\nOrdinarily, a 3-dimensional vector potential, such as the stream function in 3-dimensional fluid dynamics, requires 3 separate expansions (1 for each dimension). It is worth noting that when Vortex elements are used, FastMultipole never actually computes the vector potential vecpsi; rather, it computes two scalar components phi and chi of the Lamb-Helmholtz decomposition of the field as demonstrated by [2]. This allows us to reduce the number of expansions required to express the scalar-plus-vector potential from 4 to 2, thus reducing computational cost. It is also worth noting that phi and chi are not origin-invariant fields, and thus cannot be used to evaluate scalar or vector potentials with FMM. In other words, when a Vortex kernel is used as a source in a FMM call, the scalar_potential should not be used.\n\ninfo: Info\nWhen using Vortex elements, FastMultipole computes two scalar components phi and chi of the Lamb-Helmholtz decomposition of the field, rather than the vector potential vecpsi. This allows us to reduce the number of expansions required to express the scalar-plus-vector potential from 4 to 2, thus reducing computational cost.\n\nwarning: Warning\nWhen a Vortex kernel is used as a source in a FMM call, the scalar_potential should not be used. This is because the scalar_potential is not origin-independent under the Lamb-Helmholtz decomposition.","category":"section"},{"location":"vortex_filament/#Buffer-Interface-Functions","page":"Vortex Filament Example","title":"Buffer Interface Functions","text":"The buffer interface functions are defined for VortexFilament systems as follows:\n\nfunction FastMultipole.source_system_to_buffer!(buffer, i_buffer, system::VortexFilaments, i_body)\n    # position\n    buffer[1:3,i_buffer] .= (system.x[1,i_body]  + system.x[2,i_body]) * 0.5\n    \n    # get regularization radius\n    Γ = system.strength[i_body]\n    # Γmag = norm(Γ)\n    core_size = system.core_size[i_body]\n    buffer[4,i_buffer] = system.core_size[i_body] + 0.5 * norm(system.x[2,i_body] - system.x[1,i_body])\n\n    # remainding quantities\n    buffer[5:7,i_buffer] .= Γ\n    buffer[8:10,i_buffer] .= system.x[1,i_body]\n    buffer[11:13,i_buffer] .= system.x[2,i_body]\n    buffer[14,i_buffer] = core_size\nend\n\nBase.eltype(::VortexFilaments{TF}) where TF = TF\n\nFastMultipole.data_per_body(::VortexFilaments) = 14\n\nFastMultipole.get_position(system::VortexFilaments, i) = (system.x[1,i] + system.x[2,i]) * 0.5\n\nFastMultipole.strength_dims(system::VortexFilaments) = 3\n\nFastMultipole.get_n_bodies(system::VortexFilaments) = length(system.strength)\n\nfunction FastMultipole.buffer_to_target_system!(target_system::VortexFilaments, i_target, ::DerivativesSwitch{PS,VS,GS}, target_buffer, i_buffer) where {PS,VS,GS}\n\n    # extract from buffer\n    PS && (potential = FastMultipole.get_scalar_potential(target_buffer, i_buffer))\n    VS && (velocity = FastMultipole.get_gradient(target_buffer, i_buffer))\n    GS && (hessian = FastMultipole.get_hessian(target_buffer, i_buffer))\n\n    # load into system\n    PS && (target_system.potential[i_target] += potential)\n    VS && (target_system.gradient[i_target] += velocity)\n    GS && (target_system.hessian[i_target] += hessian)\n\nend\n\nFirst, we point out that the source_system_to_buffer! function stores a core size in row 14. Although it will not be used by any internal FastMultipole functions, it will be required by the direct! function. Since the columns of the buffer are sorted into an octree structure, they will not match the order of the original system; therefore, it is important to store essential body properties in additional rows of the buffer. We also note that the get_position function needs not return a previously-stored value; in this case, it computes the midpoint of the filament on the fly.","category":"section"},{"location":"vortex_filament/#Overloading-direct!","page":"Vortex Filament Example","title":"Overloading direct!","text":"The FastMultipole.direct! function is overloaded for VortexFilaments systems as follows:\n\nfunction get_δ(distance, core_size)\n    δ = distance < core_size ? (distance-core_size) * (distance-core_size) : zero(distance)\n    return δ\nend\n\nfunction vortex_filament_finite_core_2(x1,x2,xt,q,core_size)\n    # intermediate values\n    r1 = xt - x1\n    r2 = xt - x2\n\n    nr1 = norm(r1)\n    nr2 = norm(r2)\n\n    num = cross(r1, r2)\n    denom = nr1 * nr2 + dot(r1, r2)\n\n    # core size comes into play here\n    distance_1 = norm((x1+x2)*0.5 - xt)\n    δ1 = get_δ(distance_1, core_size)\n\n    distance_2 = norm(x1 - xt)\n    δ2 = get_δ(distance_2, core_size)\n\n    distance_3 = norm(x2 - xt)\n    δ3 = get_δ(distance_3, core_size)\n\n    # desingularized terms\n    f1 = num/(denom + δ1)\n    f2 = 1/(nr1+δ2)\n    f3 = 1/(nr2+δ3)\n\n    # evaluate velocity\n    V = (f1*(f2+f3))/(4*pi) * q\n\n    return V\nend\n\nfunction FastMultipole.direct!(target_system, target_index, derivatives_switch::DerivativesSwitch{PS,VS,GS}, source_system::VortexFilaments, source_buffer, source_index) where {PS,VS,GS}\n    for i_source in source_index\n        x1 = FastMultipole.get_vertex(source_buffer, source_system, i_source, 1)\n        x2 = FastMultipole.get_vertex(source_buffer, source_system, i_source, 2)\n        q = FastMultipole.get_strength(source_buffer, source_system, i_source)\n        core_size = source_buffer[14, i_source]\n\n        for i_target in target_index\n            xt = FastMultipole.get_position(target_system, i_target)\n\n            if VS\n                # determine sign of q\n                q_mag = norm(q) * sign(dot(q, x2-x1))\n\n                # calculate velocity\n                v = vortex_filament_finite_core_2(x1,x2,xt,q_mag,core_size)\n                FastMultipole.set_gradient!(target_system, i_target, v)\n            end\n        end\n    end\nend\n\nNote that core_size is retrieved from the buffer matrix rather than from source_system directly, as discussed previously.\n\nwarning: Warning\nThe bodies contained inside the source_system argument of the direct! function will not be in the correct order for use in the FMM. For this reason, it is not recommended to access the source_system in the direct! function except for global properties that apply to all bodies. Instead, use the source_buffer matrix as shown in the example above.","category":"section"},{"location":"vortex_filament/#Running-the-FMM","page":"Vortex Filament Example","title":"Running the FMM","text":"Let's try this out on a vortex filament system. The fmm! function is called in the same way as for the gravitational example, but with the VortexFilaments system:\n\nusing LinearAlgebra\n\n# create system\nfunction generate_filament_field(n_filaments, length_scale; strength_scale=1/n_filaments)\n    centers = rand(SVector{3,Float64}, n_filaments)\n    pts = zeros(SVector{3,Float64}, 2, n_filaments)\n    strength_vec= zeros(SVector{3,Float64}, n_filaments)\n    for (i,center) in enumerate(centers)\n        dx = (rand(SVector{3,Float64}) * 2 .- 1.0) * 0.5 * length_scale\n        pts[1,i] = center - dx\n        pts[2,i] = center + dx\n        Γ = dx / norm(dx) * rand() * strength_scale\n        strength_vec[i] = Γ\n    end\n\n    # create filaments\n    core_size = fill(1e-2, n_filaments)\n    error_tolerance = fill(1e-4, n_filaments)\n    potential = zeros(length(strength_vec))\n    gradient = zeros(SVector{3,Float64}, length(strength_vec))\n    hessian = zeros(SMatrix{3,3,Float64,9}, length(strength_vec))\n\n    return VortexFilaments(pts, strength_vec, core_size, error_tolerance, potential, gradient, hessian)\nend\n\nn_filaments = 5000\nlength_scale = 1.0 / n_filaments^(1/3)\nfilaments = generate_filament_field(n_filaments, length_scale; strength_scale=1/n_filaments)\n\n# run FMM\n_, cache, _ = fmm!(filaments; scalar_potential=false, gradient=true)\n\n# print results\nprintln(\"Induced Velocity:\\n\", filaments.gradient[1:10], \"...\")\n\nWe set scalar_potential=false and gradient=true to indicate that we want to compute the vector field (i.e. the velocity field) but not the scalar potential.","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#API","page":"Reference","title":"API","text":"The following functions are the primary user-facing API of the FastMultipole package.","category":"section"},{"location":"reference/#Compatibility-Functions","page":"Reference","title":"Compatibility Functions","text":"The following functions must be overloaded by the user to interface their code with the FastMultipole package.","category":"section"},{"location":"reference/#Data-Structures","page":"Reference","title":"Data Structures","text":"The following data structures are used by the FastMultipole package.","category":"section"},{"location":"reference/#Additional-Functions","page":"Reference","title":"Additional Functions","text":"The following functions are used internally by the FastMultipole package, but may be useful to understand for advanced users.","category":"section"},{"location":"reference/#FastMultipole.fmm!","page":"Reference","title":"FastMultipole.fmm!","text":"fmm!(target_systems::Tuple, source_systems::Tuple; optargs...)\n\nDispatches fmm! with automatic tree creation.\n\nArguments\n\ntarget_systems::Union{Tuple, {UserDefinedSystem}}: either a system object for which compatibility functions have been overloaded, or a tuple of system objects for which compatibility functions have been overloaded\nsource_systems::Union{Tuple, {UserDefinedSystem}}: either a system object for which compatibility functions have been overloaded, or a tuple of system objects for which compatibility functions have been overloaded\n\nNote: a convenience function fmm!(system) is provided, which is equivalent to fmm!(system, system). This is for situations where all system(s) act on all other systems, including themselves.\n\nOptional Arguments: Allocation\n\ntarget_buffers::Vector{<:Any}: buffers for target systems; if not provided, buffers are allocated using FastMultipole.allocate_buffers\ntarget_small_buffers::Vector{<:Any}: small buffers for target systems; if not provided, small buffers are allocated using FastMultipole.allocate_small_buffers\nsource_buffers::Vector{<:Any}: buffers for source systems; if not provided, buffers are allocated using FastMultipole.allocate_buffers\nsource_small_buffers::Vector{<:Any}: small buffers for source systems; if not provided, small buffers are allocated using FastMultipole.allocate_small_buffers\n\nOptional Arguments: Tuning Parameters\n\nexpansion_order::Int: order of multipole expansions; default is 5\nmultipole_acceptance::Float64: acceptance criterion for multipole expansions; default is 0.4\nleaf_size_target::Union{Nothing,Int}: leaf size for target systems; if not provided, the minimum of the source leaf sizes is used\nleaf_size_source::Union{Nothing,Int}: leaf size for source systems; if not provided, the default leaf size is used\nerror_tolerance::Union{Nothing,ErrorMethod}: error tolerance for multipole to local translations; if not provided, no error treatment is performed\n\nOptional Arguments: Tree Options\n\nshrink::Bool: whether to shrink branches around their bodies, accounting for finite body radius; default is true\nrecenter::Bool: whether to recenter branches around their bodies, accounting for finite body radius; default is false\ninteraction_list_method::InteractionListMethod: method for building interaction lists; default is SelfTuningTargetStop()\n\nOptional Arguments: Additional Options\n\nfarfield::Bool: whether to compute farfield interactions; default is true\nnearfield::Bool: whether to compute nearfield interactions; default is true\nself_induced::Bool: whether to compute self-induced interactions; default is true\nupward_pass::Bool: whether to perform the upward pass; default is true\nhorizontal_pass::Bool: whether to perform the horizontal pass; default is true\ndownward_pass::Bool: whether to perform the downward pass; default is true\nscalar_potential::Union{Bool,AbstractVector{Bool}}: whether to compute the scalar potential; default is false\ngradient::Union{Bool,AbstractVector{Bool}}: whether to compute the vector field; default is true\nhessian::Union{Bool,AbstractVector{Bool}}: whether to compute the vector gradient; default is false\n\n\n\n\n\n","category":"function"},{"location":"reference/#FastMultipole.tune_fmm","page":"Reference","title":"FastMultipole.tune_fmm","text":"tune_fmm(target_systems, source_systems; optargs...)\n\nTune the Fast Multipole Method (FMM) parameters for optimal performance on the given target and source systems, optionally subject to an error tolerance.\n\nArguments\n\ntarget_systems::Union{Tuple,{UserDefinedSystem}}: a user-defined system object (or a tuple of them) for which the FMM interface functions have been defined\nsource_systems::Union{Tuple,{UserDefinedSystem}}: a user-defined system object (or a tuple of them) for which the FMM interface functions have been defined\n\nKeyword Arguments\n\nerror_tolerance::Union{Nothing,Float64}: the error tolerance for the FMM; if nothing, the FMM will simply use the expansion_order keyword argument to fix the expansion order\nexpansion_order::Int: the max expansion order for the FMM; defaults to 4\nleaf_size_source::Int: the leaf size for the source systems; defaults to default_leaf_size(source_systems)\nmax_expansion_order::Int: the maximum allowable expansion order if an error tolerance is requested; defaults to 20\nmultipole_acceptances::AbstractRange{Float64}: a range of multipole acceptance critia to test; defaults to range(0.3, stop=0.8, step=0.1)\nlamb_helmholtz::Bool: whether to use the Lamb-Hellmholtz decomposition; defaults to false\nverbose::Bool: whether to print progress information; defaults to true\nkwargs...: additional keyword arguments to pass to the fmm! function\n\nReturns\n\ntuned_params::NamedTuple: a named tuple containing the best parameters found during tuning, which can be used in subsequent fmm! calls by splatting it as a keyword argument:`:\nleaf_size_source::Int: the optimal leaf size for the source systems\nexpansion_order::Int: the optimal expansion order for the FMM\nmultipole_acceptance::Float64: the optimal multipole acceptance criterion\ncache::Tuple: a tuple containing the cache used during tuning, which can be reused for subsequent fmm! calls by splatting it as a keyword argument\n\n\n\n\n\n","category":"function"},{"location":"reference/#FastMultipole.direct!-Tuple{Tuple}","page":"Reference","title":"FastMultipole.direct!","text":"direct!(systems; derivatives_switches)\n\nApplies all interactions of systems acting on itself without multipole acceleration.\n\nArguments\n\nsystems: either\na system object for which compatibility functions have been overloaded, or\na tuple of system objects for which compatibility functions have been overloaded\n(target_systems, source_systems) where target_systems and source_systems are each either a system or tuple of systems for which compatibility functions have been overloaded\n\nOptional Arguments\n\nscalar_potential::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a scalar potential from source_systems\ngradient::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a vector field from source_systems\nhessian::Bool: either a ::Bool or a ::AbstractVector{Bool} of length length(target_systems) indicating whether each system should receive a vector gradient from source_systems\nn_threads::Int: the number of threads to use for parallelization; defaults to Threads.nthreads()\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.source_system_to_buffer!","page":"Reference","title":"FastMultipole.source_system_to_buffer!","text":"source_system_to_buffer!(buffer::Matrix, i_buffer, system::{UserDefinedSystem}, i_body)\n\nCompatibility function used to sort source systems. It should be overloaded for each system (where {UserDefinedSystem} is replaced with the type of the user-defined system) to be used as a source and should behave as follows. For the i_bodyth body contained inside of system,\n\nbuffer[1:3, i_buffer] should be set to the x, y, and z coordinates of the body position used for sorting into the octree\nbuffer[4, i_buffer] should be set to the radius beyond which a multipole expansion is allowed to be evaluated (e.g. for panels, or other bodies of finite area/volume)\nbuffer[5:4+strength_dims, i_buffer] should be set to the body strength, which is a vector of length strength_dims\n\nAny additional information required for either forming multipole expansions or computing direct interactions should be stored in the rest of the column.\n\nIf a body contains vertices that are required for, e.g. computing multipole coefficients of dipole panels, these must be stored immediately following the body strength, and should be listed in a counter-clockwise order. For example, if I am using vortex tri-panels with strength_dims=3, I would set buffer[8:10,i] .= v1, buffer[11:13,i] .= v2, and bufer[14:16,i] .= v3, where v1, v2, and v3 are listed according to the right-hand-rule with thumb aligned with the panel normal vector.\n\nNote that any system acting only as a target need not overload source_system_to_buffer!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FastMultipole.data_per_body","page":"Reference","title":"FastMultipole.data_per_body","text":"data_per_body(system::{UserDefinedSystem})\n\nReturns the number of values used to represent a single body in a source system. Should be overloaded for each user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system).\n\n\n\n\n\n","category":"function"},{"location":"reference/#FastMultipole.get_position","page":"Reference","title":"FastMultipole.get_position","text":"get_position(system::{UserDefinedSystem}, i)\n\nReturns a (static) vector of length 3 containing the x, y, and z coordinates of the position of the ith body. Should be overloaded for each user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system).\n\n\n\n\n\n","category":"function"},{"location":"reference/#FastMultipole.get_previous_influence","page":"Reference","title":"FastMultipole.get_previous_influence","text":"get_previous_influence(system::{UserDefinedSystem}, i)\n\nReturns the influence of the ith body in system from the previous FMM call. The relative error is predicted by dividing the absolute error by the result of this function. Should be overloaded for each user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system).\n\nNOTE: If not overloaded, the default behavior is to return zero for both the scalar potential and vector field, effectively ignoring the relative tolerance in favor of an absolute tolerance.\n\nArguments:\n\nsystem::{UserDefinedSystem}: the user-defined system object\ni::Int: the index of the body within the system\n\nReturns:\n\nprevious_potential::Float64: the previous scalar potential at the ith body\nprevious_vector::SVector{3,Float64}: the previous vector field at the ith body\n\n\n\n\n\n","category":"function"},{"location":"reference/#FastMultipole.strength_dims","page":"Reference","title":"FastMultipole.strength_dims","text":"strength_dims(system::{UserDefinedSystem})\n\nReturns the cardinality of the vector used to define the strength of each body inside system. E.g., a point mass would return 1, and a point dipole would return 3. Should be overloaded for each user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system).\n\n\n\n\n\n","category":"function"},{"location":"reference/#FastMultipole.get_normal","page":"Reference","title":"FastMultipole.get_normal","text":"get_normal(source_buffer, source_system::{UserDefinedSystem}, i)\n\nOPTIONAL OVERLOAD:\n\nReturns the unit normal vector for the ith body of source_buffer. May be (optionally) overloaded for a user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system); otherwise, the default behavior assumes counter-clockwise ordered vertices. Note that whatever method is used should match source_system_to_buffer! for each system.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FastMultipole.get_n_bodies","page":"Reference","title":"FastMultipole.get_n_bodies","text":"get_n_bodies(system::{UserDefinedSystem})\n\nReturns the number of bodies contained inside system. Should be overloaded for each user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system).\n\n\n\n\n\n","category":"function"},{"location":"reference/#FastMultipole.body_to_multipole!","page":"Reference","title":"FastMultipole.body_to_multipole!","text":"body_to_multipole!(system::{UserDefinedSystem}, multipole_coefficients, buffer, expansion_center, bodies_index, harmonics, expansion_order)\n\nCalculates the multipole coefficients due to the bodies contained in buffer[:,bodies_index] and accumulates them in multipole_coefficients. Should be overloaded for each user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system).\n\nTypically, this is done using one of the convience functions contained within FastMultipole in one line, as\n\nbody_to_multipole!(system::MySystem, args...) = body_to_multipole!(Point{Vortex}, system, args...)\n\n\n\n\n\n","category":"function"},{"location":"reference/#FastMultipole.direct!-NTuple{6, Any}","page":"Reference","title":"FastMultipole.direct!","text":"direct!(target_buffer, target_index, derivatives_switch::DerivativesSwitch{PS,GS,HS}, ::{UserDefinedSystem}, source_buffer, source_index) where {PS,GS,HS}\n\nCalculates direct (nearfield) interactions of source_system on target_buffer. Should be overloaded or each user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system), for all source bodies in source_index, at all target bodies in target_index, as follows:\n\n# loop over source bodies\nfor i_source in source_index\n\n    # extract source body information here...\n\n    # loop over target bodies\n    for i_target in target_index\n\n        # get target position\n        target_position = get_position(target_buffer, i_target)\n\n        # evaluate influence here...\n\n        # update appropriate quantities\n        if PS\n            set_scalar_potential!(target_buffer, i_target, scalar_potential)\n        end\n        if GS\n            set_gradient!(target_buffer, i_target, gradient)\n        end\n        if HS\n            set_hessian!(target_buffer, i_target, hessian)\n        end\n\n    end\nend\n\nNote that ::{UserDefinedSystem} is used purely for overloading the method for the appropriate system, and should NOT be accessed in this function, since it will NOT be indexed according to source_index. Rather, source_buffer, which is updated using source_system_to_buffer!, should be accessed.\n\nThe following convenience getter functions are available for accessing the source system:\n\nget_position(source_system::{UserDefinedSystem}, i_body::Int): returns an SVector of length 3 containing the position of the i_body body\nget_strength(source_buffer::Matrix, source_system::{UserDefinedSystem}, i_body::Int): returns an SVector containing the strength of the i_body body\nget_vertex(source_buffer::Matrix, source_system::{UserDefinedSystem}, i_body::Int, i_vertex::Int): returns an SVector containing the x, y, and z coordinates of the i_vertex vertex of the i_body body\n\nNote also that the compile time parameters PS, GS, and HS are used to determine whether the scalar potential and vector field should be computed, respectively. This allows us to skip unnecessary calculations and improve performance.\n\n\n\n\n\n","category":"method"},{"location":"reference/#FastMultipole.buffer_to_target_system!","page":"Reference","title":"FastMultipole.buffer_to_target_system!","text":"buffer_to_target_system!(target_system::{UserDefinedSystem}, i_target, ::DerivativesSwitch{PS,GS,HS}, target_buffer, i_buffer) where {PS,GS,HS}\n\nCompatibility function used to update target systems. It should be overloaded for each system (where {UserDefinedSystem} is replaced with the type of the user-defined system) to be a target and should behave as follows. For the i_bodyth body contained inside of target_system,\n\ntarget_buffer[4, i_buffer] contains the scalar potential influence to be added to the i_target body of target_system\ntarget_buffer[5:7, i_buffer] contains the vector field influence to be added to the i_target body of target_system\ntarget_buffer[8:16, i_buffer] contains the vector field gradient to be added to the i_target body of target_system\n\nNote that any system acting only as a source (and not as a target) need not overload buffer_to_target_system!.\n\nThe following convenience functions can may be used to access the buffer:\n\nget_scalar_potential(target_buffer, i_buffer::Int): returns the scalar potential induced at the i_buffer body in target_buffer\nget_gradient(target_buffer, i_buffer::Int): returns an SVector of length 3 containing the vector field induced at the i_buffer body in target_buffer\nget_hessian(target_buffer, i_buffer::Int): returns an SMatrix of size 3x3 containing the vector gradient induced at the i_buffer body in target_buffer\n\nFor some slight performance improvements, the booleans PS, GS, and HS can be used as a switch to indicate whether the scalar potential, vector field, and vector gradient are to be stored, respectively. Since they are compile-time parameters, if statements relying on them will not incur a runtime cost.\n\n\n\n\n\n","category":"function"},{"location":"reference/#FastMultipole.has_vector_potential","page":"Reference","title":"FastMultipole.has_vector_potential","text":"has_vector_potential(system::{UserDefinedSystem})\n\nReturns true if the system induces a vector potential, false otherwise. Should be overloaded for each user-defined system object (where {UserDefinedSystem} is replaced with the type of the user-defined system).\n\n\n\n\n\n","category":"function"},{"location":"reference/#FastMultipole.DerivativesSwitch","page":"Reference","title":"FastMultipole.DerivativesSwitch","text":"DerivativesSwitch\n\nSwitch indicating whether the scalar potential, vector potential, gradient, and/or hessian should be computed for a target system. Information is stored as type parameters, allowing the compiler to compile away if statements.\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.Branch","page":"Reference","title":"FastMultipole.Branch","text":"Branch{TF,N}\n\nBranch object used to sort more than one system into an octree. Type parameters represent:\n\nTF: the floating point type (would be a dual number if using algorithmic differentiation)\nN: the number of systems represented\n\nFields\n\nbodies_index::Vector{UnitRange}: vector of unit ranges indicating the index of bodies in each represented system, respectively\nn_branches::Int: number of child branches corresponding to this branch\nbranch_index::UnitRange: indices of this branch's child branches\ni_parent::Int: index of this branch's parent\ni_leaf::Int: if this branch is a leaf, what is its index in its parent <:Tree's leaf_index field\ncenter::Vector{TF}: center of this branch at which its multipole and local expansions are centered\nradius::TF: distance from center to the farthest body contained in this branch (accounting for finite body radius if bodies are sources)\nbox::Vector{TF}: vector of length 3 containing the distances from the center to faces of a rectangular prism completely enclosing all bodies in the x, y, and z direction, respectively\nmin_potential::TF: maximum influence of any body in this branch on any body in its child branches; used to enforce a relative error tolerance\nmin_gradient::TF: maximum gradient magnitude of any body in this branch on any body in its child branches; used to enforce a relative error tolerance\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.Tree","page":"Reference","title":"FastMultipole.Tree","text":"Tree{TF,N}\n\nTree object used to sort N systems into an octree.\n\nFields\n\nbranches::Vector{Branch{TF,N}}: a vector of Branch objects composing the tree\nexpansions::Array{TF,4}: 4-dimensional array whose (1,i,j,k)th element contains the real part of the jth expansion coefficient of the kth branch, and whose (2,i,j,k)th element contains the imaginary part. If i==1, the coefficient corresponds to the scalar potential; if i==2, the coefficient corresponds to the ''\\chi'' part of the Lamb-Helmholtz decomposition of the vector potential.\nlevels_index::Vector{UnitRange{Int64}}: vector of unit ranges indicating the indices of branches at each level of the tree\nleaf_index::Vector{Int}: vector of indices of branches that are leaves\nsort_index_list::NTuple{N,Vector{Int}}: tuple of vectors of indices used to sort the bodies in each system into the tree\ninverse_sort_index_list::NTuple{N,Vector{Int}}: tuple of vectors of indices used to undo the sort operation performed by sort_index_list\nbuffers::NTuple{N,Matrix{TF}}: tuple of buffers used to store the bodies computed influence of each system in the tree, as explained in FastMultipole.allocate_buffers\nsmall_buffers::Vector{Matrix{TF}}: vector of buffers used to pidgeon-hole sort bodies into the tree, as explained in FastMultipole.allocate_small_buffers\nexpansion_order::Int64: the maximum storable expansion order\nleaf_size::SVector{N,Int64}: maximum number of bodies in a leaf for each system; if multiple systems are represented, the actual maximum depends on the InteractionListMethod used to create the tree\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.ProbeSystem","page":"Reference","title":"FastMultipole.ProbeSystem","text":"ProbeSystem{TF}\n\nConvenience system for defining locations at which the potential, vector field, or vector gradient may be desired. Interface functions are already defined and overloaded.\n\nFields\n\nposition::Vector{SVector{3,TF}}: vector of probe positions\nscalar_potential::Vector{TF}: vector of scalar potential values at the positions\ngradient::Vector{SVector{3,TF}}: vector of vector field values at the positions\nhessian::Vector{SMatrix{3,3,TF,9}}: vector of Hessian matrices at the positions\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.Cache","page":"Reference","title":"FastMultipole.Cache","text":"Cache{TF,NT,NS}\n\nCache object used to store system buffers to avoid repeated allocations.\n\nFields\n\ntarget_buffers::NTuple{NT, Matrix{TF}}: tuple of length NT containing buffers for target systems\nsource_buffers::NTuple{NS, Matrix{TF}}: tuple of length NS containing buffers for source systems\ntarget_small_buffers::Vector{Matrix{TF}}: vector of small buffers used for pidgeon-hole sorting target systems into the octree\nsource_small_buffers::Vector{Matrix{TF}}: vector of small buffers used for pidgeon-hole sorting source systems into the octree\n\n\n\n\n\n","category":"type"},{"location":"reference/#FastMultipole.allocate_buffers","page":"Reference","title":"FastMultipole.allocate_buffers","text":"allocate_buffers(systems::Tuple, target::Bool)\n\nAllocates buffers for the given systems. \n\nArguments\n\nsystems::Tuple: tuple of systems for which to allocate buffers\ntarget::Bool: if true, allocates space for body position, scalar potential, gradient, hessian matrix, and previous influence for relative error tolerance; otherwise, allocates space for information provided by the user-defined source_system_to_buffer!\nTF: element type of the buffers\n\nReturns\n\nbuffers::NTuple{N,Matrix{TF}}: tuple of N matrices, one for each system, as follows:\nif target==true, each matrix has size (18,N), where N is the number of bodies in the system; indices correspond to:\n(1:3,i) - x, y, and z coordinates of the ith body\n(4,i) - scalar potential induced at the ith body\n(5:7,i) - x, y, and z components of the vector field induced at the ith body\n(8:16,i) - hessian of the scalar potential induced at the ith body\n(17,i) - estimate of the scalar potential induced at the ith body used for relative error tolerance\n(18,i) - estimate of the vector field magnitude induced at the ith body used for relative error tolerance\nif target==false, each matrix has size (M,N), where N is the number of bodies in the system, and M is determined by the user-defined source_system_to_buffer! function\n\n\n\n\n\n","category":"function"},{"location":"reference/#FastMultipole.allocate_small_buffers","page":"Reference","title":"FastMultipole.allocate_small_buffers","text":"allocate_small_buffers(systems::Tuple; target=false)\n\nAllocates small buffers for the given systems to be used in pidgeon-hole sorting bodies into the octree.\n\nArguments\n\nsystems::Tuple: tuple of systems for which to allocate buffers\nTF: element type of the buffers\n\nReturns\n\nsmall_buffers::Vector{Matrix{TF}}: vector of matrices of size (5,N) allocated for each system, where:\nN is the number of bodies in the system\nindices (1:3,i) correspond to the x, y, and z coordinates of the ith body\nindex (4,i) corresponds to the estimated scalar potential of the ith body\nindex (5,i) corresponds to the estimated vector field magnitude of the ith body\n\n\n\n\n\n","category":"function"},{"location":"#FastMultipole","page":"Introduction","title":"FastMultipole","text":"A fast, multi-system, multi-kernel, differentiable implementation of the fast multipole method for use with scalar-plus-vector potential N-body problems in pure Julia.\n\nAuthor: Ryan Anderson\n\nFeatures:\n\nsolves N-body problems governed by the Laplace (1r) kernel, with work planned to support the Helmholtz kernel in the future\nincorporates seamlessly into existing Julia code without modifications (just the addition of a few interface functions)\noffers convenience functions for determining the expansion coefficients for source, dipole, and vortex points, filaments, and panels (this list is growing!)\nprovides velocity and velocity gradient (or their equivalent for non-fluids problems) obtained using analytic expressions (no finite difference)\nuses O(p^3) translation operators (where p is the expansion order)\nautomated CPU-parallelization of expansions and direct interactions\nsupports GPU-parallelization of direct interactions with user-defined kernels\nForwardDiff and ReverseDiff compatible\n\nInstallation:\n\npkg> add https://github.com/byuflowlab/FastMultipole.git\n\nDocumentation:\n\nlearn basic useage in the Quick Start tutorial\nsee how to implement FastMultipole in your code in the Gravitational Example\nexplore more details in the Vortex Filament Example\nlearn about the Tuning Parameters\nrun FMM simultaneously on multiple systems in Multiple Systems section\nfine-tune performance in the Automated Tuning\nsee the full API","category":"section"}]
}
